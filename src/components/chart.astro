---
import Stat from "./stat.astro";

type Props = astroHTML.JSX.CanvasHTMLAttributes & {
  label: string;
  listenTo: string;
};

const { label, class: classes, listenTo, ...canvasProps } = Astro.props;
---

<label
  data-element="chart"
  class:list={["grid grid-cols-[minmax(0,1fr)] gap-8 text-shadow-md", classes]}
>
  <div>
    <p class="text-5xl text-center">{label}</p>
  </div>
  <div class="grid gap-2">
    <div class="grid grid-cols-2 gap-4">
      <Stat data-element="average" label="Average" content="6.5" />
      <Stat data-element="trend" label="Trend" content="+20%" />
    </div>
    <canvas {...canvasProps} class="rounded-sm w-full" data-listen-to={listenTo}
    ></canvas>
  </div>
</label>

<script>
  import { Chart, registerables } from "chart.js";
  import type { ChartEventDetail, Rating } from "../utils/db";
  import { getCssColor } from "../utils/color";
  import { format } from "date-fns";

  Chart.register(...registerables);

  function createChart(canvas: HTMLCanvasElement): Chart<"bar", number[]> {
    const dark = getCssColor("--color-dark").toString();
    return new Chart<"bar", number[]>(canvas, {
      type: "bar",
      data: {
        labels: [],
        datasets: [
          {
            label: "Rating",
            data: [],
            backgroundColor: dark,
          },
        ],
      },
      options: {
        aspectRatio: 1.5 / 1,
        layout: {
          padding: {
            top: 32,
            left: 0,
            right: 0,
            bottom: 12,
          },
        },
        indexAxis: "x",
        animations: {
          // kill horizontal stuff explicitly
          x: {
            duration: 0,
          },
          y: {
            duration: 0,
          },

          // redefine the default numeric group so it DOES NOT include x/width
          numbers: {
            type: "number",
            properties: ["y", "base"], // only grow vertically
            duration: 800,
            easing: "easeOutCubic",
          },
        },
        scales: {
          x: {
            grid: {
              display: false,
              color: dark,
              lineWidth: 1,
              tickWidth: 1,
            },
            ticks: {
              color: dark,
            },
            border: {
              display: false,
            },
          },
          y: {
            min: 0,
            max: 10,
            grid: {
              color: dark,
              lineWidth: 1,
            },
            ticks: {
              stepSize: 1,
              display: false,
            },
            border: {
              display: false,
            },
          },
        },
        plugins: {
          legend: {
            display: false,
          },
          tooltip: {
            enabled: false,
          },
        },
      },
    });
  }

  function getAverage(ratings: Rating[]) {
    if (ratings.length === 0) {
      return 0;
    }

    let total = 0;
    for (const r of ratings) {
      if (r.rating === null) {
        continue;
      }

      total += r.rating;
    }

    return total / ratings.length;
  }

  function getTrend(thisPeriod: Rating[], previousPeriod: Rating[]) {
    const averageThis = getAverage(thisPeriod);
    const averagePrevious = getAverage(previousPeriod);

    if (averagePrevious === 0 || averageThis === 0) {
      return "0%";
    }

    // percent change
    const percent = ((averageThis - averagePrevious) / averagePrevious) * 100;
    return `${percent.toFixed(0)}%`;
  }

  document.addEventListener("DOMContentLoaded", async () => {
    const chartContainers = [
      ...document.querySelectorAll("[data-element='chart']"),
    ];

    for (const chartContainer of chartContainers) {
      const averageElement = chartContainer.querySelector(
        "[data-element='average'] > p:nth-child(2)"
      );
      const trendElement = chartContainer.querySelector(
        "[data-element='trend'] > p:nth-child(2)"
      );
      const canvas = chartContainer.querySelector("canvas");

      if (!averageElement) {
        console.error("Average element not found in chart container");
        continue;
      }

      if (!trendElement) {
        console.error("Trend element not found in chart container");
        continue;
      }

      if (!canvas) {
        console.error("Canvas element not found in chart container");
        continue;
      }

      const listenTo = canvas.dataset["listenTo"];
      if (!listenTo) {
        console.error("No valid 'listTo' event name found.");
        return;
      }

      const chart = createChart(canvas);

      window.addEventListener(listenTo, (event) => {
        const chartEvent = event as CustomEvent<ChartEventDetail>;
        const { thisPeriod, previousPeriod } = chartEvent.detail;

        // use the period arrays provided by the event
        const average = getAverage(thisPeriod);
        const trend = getTrend(thisPeriod, previousPeriod);

        averageElement.textContent = average.toFixed(1);
        trendElement.textContent = trend;

        const labels = thisPeriod.map((r) => format(r.date, "dd.MM.yy"));
        const ratingValues = thisPeriod.map((r) => r.rating);

        console.log("Updating chart data:", { labels, ratingValues });
        chart.data.labels = labels;
        chart.data.datasets[0].data = ratingValues.map((r) => r ?? 0);
        chart.update();
      });
    }
  });
</script>
